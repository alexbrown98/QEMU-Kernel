-------------------------------------------------------------------------------

1. Instructions

- replace any [...] with free text,
  and
- replace the [?] with an X if you have completed that stage,
- replace the [?] with an * if you have attempted that stage, but you know
  it doesn't work completely; document why you think it doesn't work, plus
  what you would do to fix the problem, at the end of the marksheet.

-------------------------------------------------------------------------------

2. Information

So that we can calibrate and improve the assignment in the future, give us
a rough idea how long (in hours) you spent on it *in total*:

effort : [100] hours

-------------------------------------------------------------------------------

3. Citation

Clearly it might have an influence on your mark, but the use of third-party
resources is allowed *iff.* it

- hasn't been explicitly prohibited by the assignment description, *and*
- is correctly cited.

Let us know any third-party source code or resources you used (if any) so
it's clear what's your work and what isn't:

[http://lucteo.ro/2018/12/28/modern-dining-philosophers/  <- this website is what i used
as a guideline to design my dining philospher solution]

-------------------------------------------------------------------------------

4. Marking

The following gives a stage-by-stage description of the assignment marking
scheme.  Note this acts as an indicative guideline only, including weights
for each more obvious aspect (e.g., functional correctness); other aspects
outside this list can warrant an increase/decrease in marks, with examples
including hard to quantify features such as style, efficiency, robustness, 
generality, or realism of a solution.  Put another way, identifying then
reasoning about these latter aspects forms part of the assessment, so they
are not (necessarily) detailed explicitly.

    Stage 1 : a baseline kernel
[X]           - pre-emptive multi-tasking                            ( 30%)
[X]           - priority-based scheduler                             ( 10%)

    Stage 2 : closed generalisations and enhancements
[X]           - fork, exec, and exit system calls                    ( 15%)
[X]           - Inter-Process Communication (IPC)                    ( 15%)

    Stage 3 : open   generalisations and enhancements                ( 30%)
[?]           - MMU-based protection and virtualisation
                *OR*
[X]           - LCD screen and PS/2 device drivers and GUI
                *OR*
[?]           - file system based on simplified, emulated disk
                *OR*
[?]           - kernel port to real, physical hardware                     

                                                                     ------
                                                                     (100%)

-------------------------------------------------------------------------------

5. Documentation

Any other documentation, notes or comments that you think are important or
might be easy to overlook (e.g., a subtle issue or technique in associated
source code) should go here:

[

IMPORTAN POINTS:
*** whenever i run my solution on different computers i get an error for the disk.h file not being found. If you have this problem, this can be fixed by changing 
#include "/home/alex/Desktop/SCP/COMS20001-CW2/Stage 2a/device/disk.h"
on line 30 of hilevel.h to point to the device/disk.h location on your machine. Sorry for this inconvenience but i wasnt sure how to fix it. ***

1. turn the terminal-based gui on and off with the console commands <dashboard> and <dashboardoff>.
2. run the dining philosophers program with the console command <execute phil_pipe>. You can do this with the gui on and off to view different aspects of how the program works.
3. Included are two screenshots ( the gui and a snippet of the text-flow from the philosopher process).

Scheduler: 
Implemented a scheduler that gives scores to processes according to the formula
score = age + priority (where priority is set by default to 1 for user-processes and can be 
changed with the setPrio <pid> <priority> console command. This is an improvement from round-robing scheduling because it allows more important processes (such as the console) to be run at a much higher frequency than less importan processes. It can however introduce small stravation problems if a process priority is set very high and there are many other processes with minimal priority (which will however at some point be executed due to the algorithm also accounting for the age i.e how long it has been ready for).

IPC:
Created a pipe data structure with the fields data, available and written, which correspond to the data being written, the availability of the pipe (i.e if it is beeing used) and whether it is holding data or not. 
All pipes are held in the array pipeTab.
For the dining philosopher problem, 16 philosophers are spawned and 16 pipes are created, and each philosopher has access to the file descriptors of 1 unique pipe.
A waiter process is also created that has access to all 16 pipes.
The pipes are used by the philosophers and the waiter to communicate requests and responses (i.e asking and receiving of forks). Semaphores are also used to avoid syncrhonization problems and to achieve mutual exclusion. Expanding on that, mutual exclusion is achieved since forks are provided in-between blocking channels (pipes) and forks are represented in arrays which cannot be accessed concurrently due to the serial nature of the implementation.
Starvation is avoided since requests are handled in a for-loop that iterates through all philospoher processes, and if a request is denied, it is not erased from the pipe so it will still be available on the next iteration of the for-loop.

If you would like to see the dining philosopher program working, i would recommend doing so with the gui off and the timer frequency set to the default 2s (instead of the much faster frequency i have now). This way you will be able to see the text-based flow of what each process is doing at any given time.

GUI:
2 Guis have been implemented. 
The first one is a terminal-based gui in the window where the make launch-qemu command is used. A dashboard is printed to the terminal every time there is a clock tick that shows all processes in the PCB array including pid, priority and status (executing, ready, terminated etc). I incresed the clock-frequency so it is easier to see what is going on when the philosophers are running. This can be viewed by : 1. issuing the command <dashboard> in the console terminal. 2. issuing the command <execute phil_pipe> in the console terminal. This will switch on the GUI and start the philosopher program, and you will be able to see the priority-bases scheduler working.

The second one is the LCD GUI by using the PS/2 driver. Is it unfinished and has very little functionality, apart from printing in the LCD window large letters that correspond to key presses on the keyboard. This was done by parsing the bytes received from PS/0 and filling in specific pixels for each letter. I planned to implement the functionality from the first GUI discussed above to this GUI but I run out of time.
Drawing functions for the gui can be found in kernel/draw.c .

I tried to make my code as readable as possible with logical variable names and lots of comments.














]

-------------------------------------------------------------------------------
